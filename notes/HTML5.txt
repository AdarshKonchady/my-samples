New HTML5 Elements
    - The most interesting new elements are:
    - New semantic elements like <header>, <footer>, <article>, and <section>.
    - New form control attributes like number, date, time, calendar, and range.
    - New graphic elements: <svg> and <canvas>.
    - New multimedia elements: <audio> and <video>.


New HTML5 API's (Application Programming Interfaces)
    - HTML Geolocation
    - HTML Drag and Drop
    - HTML Local Storage
    - HTML Application Cache
    - HTML Web Workers
    - HTML SSE


HTML <!DOCTYPE> Declaration
    - The <!DOCTYPE> declaration must be the very first thing in your HTML document, before the <html> tag.
    - The <!DOCTYPE> declaration is not an HTML tag; it is an instruction to the web browser about what version of HTML the page is written in.
    - In HTML 4.01, the <!DOCTYPE> declaration refers to a DTD, because HTML 4.01 was based on SGML. The DTD specifies the rules for the markup language, so that the browsers render the content correctly.
    - HTML5 is not based on SGML, and therefore does not require a reference to a DTD.
    - Tip: Always add the <!DOCTYPE> declaration to your HTML documents, so that the browser knows what type of document to expect.
        <!DOCTYPE html>
        <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
        <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">


HTML5 Semantic Elements
    - A semantic element clearly describes its meaning to both the browser and the developer.
    - Examples of non-semantic elements: <div> and <span> - Tells nothing about its content.
    - Examples of semantic elements: <form>, <table>, and <img> - Clearly defines its content.
        <article>	Defines an article
        <aside>	Defines content aside from the page content
        <details>	Defines additional details that the user can view or hide
        <figcaption>	Defines a caption for a <figure> element
        <figure>	Specifies self-contained content, like illustrations, diagrams, photos, code listings, etc.
        <footer>	Defines a footer for a document or section
        <header>	Specifies a header for a document or section
        <main>	Specifies the main content of a document
        <mark>	Defines marked/highlighted text
        <nav>	Defines navigation links
        <section>	Defines a section in a document
        <summary>	Defines a visible heading for a <details> element
        <time>	Defines a date/time


HTML5 Input Types
    number
        - The <input type="number"> is used for input fields that should contain a numeric value.
        - You can set restrictions on the numbers.
        - <input type="number" name="quantity" min="1" max="5">

    date
        - The <input type="date"> is used for input fields that should contain a date.
        - Depending on browser support, a date picker can show up in the input field.
        - <input type="date" name="bday" max="1979-12-31" min="2000-01-02" />

    datetime-local
        - The <input type="datetime-local"> allows the user to select a date and time (no time zone).
        - Depending on browser support, a date picker can show up in the input field.

    email
        - The <input type="email"> is used for input fields that should contain an e-mail address.
        - Depending on browser support, the e-mail address can be automatically validated when submitted.
        - Some smartphones recognize the email type, and adds ".com" to the keyboard to match email input.

    month
        - The <input type="month"> allows the user to select a month and year.
        - Depending on browser support, a date picker can show up in the input field.

    color
        - The <input type="color"> is used for input fields that should contain a color.
        - Depending on browser support, a color picker can show up in the input field.

    range
        - The <input type="range"> is used for input fields that should contain a value within a range.
        - Depending on browser support, the input field can be displayed as a slider control.

    search
        - The <input type="search"> is used for search fields (a search field behaves like a regular text field).

    tel
        - The <input type="tel"> is used for input fields that should contain a telephone number.
        - The tel type is currently supported only in Safari 8.

    time
        - The <input type="time"> allows the user to select a time (no time zone).
        - Depending on browser support, a time picker can show up in the input field.

    url
        - The <input type="url"> is used for input fields that should contain a URL address.
        - Depending on browser support, the url field can be automatically validated when submitted.
        - Some smartphones recognize the url type, and adds ".com" to the keyboard to match url input.

    week
        - The <input type="week"> allows the user to select a week and year.
        - Depending on browser support, a date picker can show up in the input field.


HTML5 Canvas
    - The HTML <canvas> element is used to draw graphics, on the fly, via scripting (usually JavaScript).
    - The <canvas> element is only a container for graphics. You must use a script to actually draw the graphics.
    - Canvas has several methods for drawing paths, boxes, circles, text, and adding images.


HTML5 SVG
    - SVG stands for Scalable Vector Graphics. SVG is used to define graphics for the Web. SVG is a W3C recommendation
    - The HTML <svg> element (introduced in HTML5) is a container for SVG graphics.
    - SVG has several methods for drawing paths, boxes, circles, text, and graphic images.


Differences Between SVG and Canvas
    - SVG is a language for describing 2D graphics in XML.
    - Canvas draws 2D graphics, on the fly (with a JavaScript).
    - SVG is XML based, which means that every element is available within the SVG DOM. You can attach JavaScript event handlers for an element.
    - In SVG, each drawn shape is remembered as an object. If attributes of an SVG object are changed, the browser can automatically re-render the shape.
    - Canvas is rendered pixel by pixel. In canvas, once the graphic is drawn, it is forgotten by the browser. If its position should be changed, the entire scene needs to be redrawn, including any objects that might have been covered by the graphic.


Comparison of Canvas and SVG
    Canvas
        - Resolution dependent
        - No support for event handlers
        - Poor text rendering capabilities
        - You can save the resulting image as .png or .jpg
        - Well suited for graphic-intensive games
    SVG
        - Resolution independent
        - Support for event handlers
        - Best suited for applications with large rendering areas (Google Maps)
        - Slow rendering if complex (anything that uses the DOM a lot will be slow)
        - Not suited for game applications


HTML5 Audio
    - HTML5 provides a standard for playing audio files.
    - Before HTML5, there was no standard for playing audio files on a web page.
    - Before HTML5, audio files could only be played with a plug-in (like flash).
    - The HTML5 <audio> element specifies a standard way to embed audio in a web page.

    Example:
        <audio controls>
          <source src="horse.ogg" type="audio/ogg">
          <source src="horse.mp3" type="audio/mpeg">
          Your browser does not support the audio element.
        </audio>

    HTML Audio - How It Works
        - The controls attribute adds audio controls, like play, pause, and volume.
        - Text between the <audio> and </audio> tags will display in browsers that do not support the <audio> element.
        - Multiple <source> elements can link to different audio files. The browser will use the first recognized format.

    HTML Audio - Methods, Properties, and Events
        - HTML5 defines DOM methods, properties, and events for the <audio> element.
        - This allows you to load, play, and pause audios, as well as set duration and volume.
        - There are also DOM events that can notify you when an audio begins to play, is paused, etc.


HTML5 Video
    - Playing Videos in HTML
    - Before HTML5, there was no standard for showing videos on a web page.
    - Before HTML5, videos could only be played with a plug-in (like flash).
    - The HTML5 <video> element specifies a standard way to embed a video in a web page.

    Example:
        <video width="320" height="240" controls>
          <source src="movie.mp4" type="video/mp4">
          <source src="movie.ogg" type="video/ogg">
          Your browser does not support the video tag.
        </video>

    How it Works
        - The controls attribute adds video controls, like play, pause, and volume.
        - It is a good idea to always include width and height attributes.
        - If height and width are not set, the browser does not know the size of the video. The effect will be that the page will change (or flicker) while the video loads.
        - Text between the <video> and </video> tags will only display in browsers that do not support the <video> element.
        - Multiple <source> elements can link to different video files. The browser will use the first recognized format.

    HTML <video> Autoplay
        To start a video automatically use the autoplay attribute:

    HTML Video - Methods, Properties, and Events
        - HTML5 defines DOM methods, properties, and events for the <video> element.
        - This allows you to load, play, and pause videos, as well as setting duration and volume.
        - There are also DOM events that can notify you when a video begins to play, is paused, etc.


HTML5 Geolocation
    - The HTML Geolocation API is used to locate a user's position.
    - The HTML Geolocation API is used to get the geographical position of a user.
    - Since this can compromise privacy, the position is not available unless the user approves it.

    Using HTML Geolocation:
        - The getCurrentPosition() method is used to get the user's position.
        - The example below returns the latitude and longitude of the user's position

    Example:
        <script>
          var x = document.getElementById("demo");
          function getLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(showPosition);
            } else {
                x.innerHTML = "Geolocation is not supported by this browser.";
            }
          }
          function showPosition(position) {
            x.innerHTML = "Latitude: " + position.coords.latitude +
            "<br>Longitude: " + position.coords.longitude;
          }
        </script>
        Example explained:
            - Check if Geolocation is supported
            - If supported, run the getCurrentPosition() method. If not, display a message to the user
            - If the getCurrentPosition() method is successful, it returns a coordinates object to the function specified in the parameter (showPosition)
            - The showPosition() function outputs the Latitude and Longitude


HTML5 Drag and Drop
    - Drag and drop is a very common feature. It is when you "grab" an object and drag it to a different location.
    - In HTML5, drag and drop is part of the standard, and any element can be draggable.

    Example:
        <div id="div1" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
        <img id="drag1" src="img_logo.gif" draggable="true" ondragstart="drag(event)" />
        <script>
          function allowDrop(ev) {
              ev.preventDefault();
          }
          function drag(ev) {
              ev.dataTransfer.setData("text", ev.target.id);
          }
          function drop(ev) {
              ev.preventDefault();
              var data = ev.dataTransfer.getData("text");
              ev.target.appendChild(document.getElementById(data));
          }
        </script>

    Make an Element Draggable
        - First of all: To make an element draggable, set the draggable attribute to true:
            <img draggable="true">

    What to Drag - ondragstart and setData()
        - Then, specify what should happen when the element is dragged.
        - In the example above, the ondragstart attribute calls a function, drag(event), that specifies what data to be dragged.
        - The dataTransfer.setData() method sets the data type and the value of the dragged data:
            function drag(ev) {
              ev.dataTransfer.setData("text", ev.target.id);
            }
        - In this case, the data type is "text" and the value is the id of the draggable element ("drag1").

    Where to Drop - ondragover
        - The ondragover event specifies where the dragged data can be dropped.
        - By default, data/elements cannot be dropped in other elements. To allow a drop, we must prevent the default handling of the element.
        - This is done by calling the event.preventDefault() method for the ondragover event:
            event.preventDefault()

    Do the Drop - ondrop
        - When the dragged data is dropped, a drop event occurs.
        - In the example above, the ondrop attribute calls a function, drop(event):
            function drop(ev) {
                ev.preventDefault();
                var data = ev.dataTransfer.getData("text");
                ev.target.appendChild(document.getElementById(data));
            }
        Code explained:
            - Call preventDefault() to prevent the browser default handling of the data (default is open as link on drop)
            - Get the dragged data with the dataTransfer.getData() method. This method will return any data that was set to the same type in the setData() method
            - The dragged data is the id of the dragged element ("drag1")
            - Append the dragged element into the drop element


HTML5 Local Storage
    - HTML local storage, better than cookies.
    - With local storage, web applications can store data locally within the user's browser.
    - Before HTML5, application data had to be stored in cookies, included in every server request. Local storage is more secure, and large amounts of data can be stored locally, without affecting website performance.
    - Unlike cookies, the storage limit is far larger (at least 5MB) and information is never transferred to the server.
    - Local storage is per origin (per domain and protocol). All pages, from one origin, can store and access the same data.

    HTML Local Storage Objects:
        - HTML local storage provides two objects for storing data on the client:
        - window.localStorage - stores data with no expiration date
        - window.sessionStorage - stores data for one session (data is lost when the browser tab is closed)
        - Before using local storage, check browser support for localStorage and sessionStorage:
            if(typeof(Storage) !== "undefined") {
              // Code for localStorage/sessionStorage.
            } else {
              // Sorry! No Web Storage support..
            }

    The localStorage Object
        - The localStorage object stores the data with no expiration date. The data will not be deleted when the browser is closed, and will be available the next day, week, or year.
            localStorage.setItem("lastname", "Smith"); // Store
            localStorage.getItem("lastname"); // Retrieve
            localStorage.removeItem("lastname"); // Remove

    The sessionStorage Object
        - The sessionStorage object is equal to the localStorage object, except that it stores the data for only one session. The data is deleted when the user closes the specific browser tab.
            sessionStorage.clickcount // Store


HTML5 Application Cache
    - With application cache it is easy to make an offline version of a web application, by creating a cache manifest file.
    - HTML5 introduces application cache, which means that a web application is cached, and accessible without an internet connection.

    Application cache gives an application three advantages:
        Offline browsing - users can use the application when they're offline
        Speed - cached resources load faster
        Reduced server load - the browser will only download updated/changed resources from the server

    Cache Manifest Basics
        - To enable application cache, include the manifest attribute in the document's <html> tag:
        - Example:
            <html manifest="demo.appcache"></html>
        - Every page with the manifest attribute specified will be cached when the user visits it. If the manifest attribute is not specified, the page will not be cached (unless the page is specified directly in the manifest file).
        - The recommended file extension for manifest files is: ".appcache"
        - A manifest file needs to be served with the correct media type, which is "text/cache-manifest". Must be configured on the web server.

    The Manifest File
        - The manifest file is a simple text file, which tells the browser what to cache (and what to never cache).
        - The manifest file has three sections:
            CACHE MANIFEST - Files listed under this header will be cached after they are downloaded for the first time
            NETWORK - Files listed under this header require a connection to the server, and will never be cached
            FALLBACK - Files listed under this header specifies fallback pages if a page is inaccessible

        CACHE MANIFEST
            - The first line, CACHE MANIFEST, is required:
                CACHE MANIFEST
                /theme.css
                /logo.gif
                /main.js
            - The manifest file above lists three resources: a CSS file, a GIF image, and a JavaScript file. When the manifest file is loaded, the browser will download the three files from the root directory of the web site. Then, whenever the user is not connected to the internet, the resources will still be available.

        NETWORK
            - The NETWORK section below specifies that the file "login.asp" should never be cached, and will not be available offline:
                NETWORK:
                login.asp
            - An asterisk can be used to indicate that all other resources/files require an internet connection:
                NETWORK:
                *
        FALLBACK
            - The FALLBACK section below specifies that "offline.html" will be served in place of all files in the /html/ catalog, in case an internet connection cannot be established:
                FALLBACK:
                /html/ /offline.html
            - Note: The first URI is the resource, the second is the fallback.

    Updating the Cache
        Once an application is cached, it remains cached until one of the following happens:
            - The user clears the browser's cache
            - The manifest file is modified (see tip below)
            - The application cache is programmatically updated

    Notes on Application Cache
        - Be careful with what you cache.
        - Once a file is cached, the browser will continue to show the cached version, even if you change the file on the server. To ensure the browser updates the cache, you need to change the manifest file.
        - Note: Browsers may have different size limits for cached data (some browsers have a 5MB limit per site).


HTML5 Web Workers
    - A web worker is a JavaScript running in the background, without affecting the performance of the page
    - When executing scripts in an HTML page, the page becomes unresponsive until the script is finished.
    - A web worker is a JavaScript that runs in the background, independently of other scripts, without affecting the performance of the page. You can continue to do whatever you want: clicking, selecting things, etc., while the web worker runs in the background.
    - Check Web Worker Support:
        Before creating a web worker, check whether the user's browser supports it:
          if(typeof(Worker) !== "undefined") {
            // Yes! Web worker support!
            // Some code.....
          } else {
            // Sorry! No Web Worker support..
          }

    Create a Web Worker File:
        - Now, let's create our web worker in an external JavaScript.
        - Here, we create a script that counts. The script is stored in the "demo_workers.js" file:
            var i = 0;
            function timedCount() {
                i = i + 1;
                postMessage(i);
                setTimeout("timedCount()",500);
            }
            timedCount();
        - The important part of the code above is the postMessage() method - which is used to post a message back to the HTML page.
        - Note: Normally web workers are not used for such simple scripts, but for more CPU intensive tasks.

    Create a Web Worker Object:
        - Now that we have the web worker file, we need to call it from an HTML page.
        - The following lines checks if the worker already exists, if not - it creates a new web worker object and runs the code in "demo_workers.js":
            if(typeof(w) == "undefined") {
                w = new Worker("demo_workers.js");
            }
        - Then we can send and receive messages from the web worker.
        - Add an "onmessage" event listener to the web worker.
            w.onmessage = function(event){
                document.getElementById("result").innerHTML = event.data;
            };
        - When the web worker posts a message, the code within the event listener is executed. The data from the web worker is stored in event.data.

    Terminate a Web Worker:
        - When a web worker object is created, it will continue to listen for messages (even after the external script is finished) until it is terminated.
        - To terminate a web worker, and free browser/computer resources, use the terminate() method:
            w.terminate();

    Reuse the Web Worker
        - If you set the worker variable to undefined, after it has been terminated, you can reuse the code:
            w = undefined;
        - Example:
            <p>Count numbers: <output id="result"></output></p>
            <button onclick="startWorker()">Start Worker</button>
            <button onclick="stopWorker()">Stop Worker</button>
            <script>
                var w;
                function startWorker() {
                    if(typeof(Worker) !== "undefined") {
                        if(typeof(w) == "undefined") {
                            w = new Worker("demo_workers.js");
                        }
                        w.onmessage = function(event) {
                            document.getElementById("result").innerHTML = event.data;
                        };
                    } else {
                        document.getElementById("result").innerHTML = "Sorry! No Web Worker support.";
                    }
                }
                function stopWorker() {
                    w.terminate();
                    w = undefined;
                }
            </script>

    Web Workers and the DOM
        Since web workers are in external files, they do not have access to the following JavaScript objects:
            - The window object
            - The document object
            - The parent object


HTML5 Server-Sent Events
    - Server-Sent Events allow a web page to get updates from a server.
    - Server-Sent Events - One Way Messaging:
        - A server-sent event is when a web page automatically gets updates from a server.
        - This was also possible before, but the web page would have to ask if any updates were available. With server-sent events, the updates come automatically.
        - Examples: Facebook/Twitter updates, stock price updates, news feeds, sport results, etc.

    Receive Server-Sent Event Notifications
        - The EventSource object is used to receive server-sent event notifications:
        - Example:
            var source = new EventSource("demo_sse.php");
            source.onmessage = function(event) {
                document.getElementById("result").innerHTML += event.data + "<br>";
            };
            Example explained:
                - Create a new EventSource object, and specify the URL of the page sending the updates (in this example "demo_sse.php")
                - Each time an update is received, the onmessage event occurs
                - When an onmessage event occurs, put the received data into the element with id="result"

    Check Server-Sent Events Support
        - In the tryit example above there were some extra lines of code to check browser support for server-sent events:
            if(typeof(EventSource) !== "undefined") {
              // Yes! Server-sent events support!
              // Some code.....
            } else {
              // Sorry! No server-sent events support..
            }

    Server-Side Code Example:
        - For the example above to work, you need a server capable of sending data updates (like PHP or ASP).
        - The server-side event stream syntax is simple. Set the "Content-Type" header to "text/event-stream". Now you can start sending event streams.

    The EventSource Object
        - In the examples above we used the onmessage event to get messages. But other events are also available:
            - onopen	When a connection to the server is opened
            - onmessage	When a message is received
            - onerror	When an error occurs
